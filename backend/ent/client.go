// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/cble-platform/cble/backend/ent/migrate"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/cble-platform/cble/backend/ent/blueprint"
	"github.com/cble-platform/cble/backend/ent/deployment"
	"github.com/cble-platform/cble/backend/ent/deploymentnode"
	"github.com/cble-platform/cble/backend/ent/grantedpermission"
	"github.com/cble-platform/cble/backend/ent/group"
	"github.com/cble-platform/cble/backend/ent/groupmembership"
	"github.com/cble-platform/cble/backend/ent/membership"
	"github.com/cble-platform/cble/backend/ent/project"
	entprovider "github.com/cble-platform/cble/backend/ent/provider"
	"github.com/cble-platform/cble/backend/ent/resource"
	"github.com/cble-platform/cble/backend/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Blueprint is the client for interacting with the Blueprint builders.
	Blueprint *BlueprintClient
	// Deployment is the client for interacting with the Deployment builders.
	Deployment *DeploymentClient
	// DeploymentNode is the client for interacting with the DeploymentNode builders.
	DeploymentNode *DeploymentNodeClient
	// GrantedPermission is the client for interacting with the GrantedPermission builders.
	GrantedPermission *GrantedPermissionClient
	// Group is the client for interacting with the Group builders.
	Group *GroupClient
	// GroupMembership is the client for interacting with the GroupMembership builders.
	GroupMembership *GroupMembershipClient
	// Membership is the client for interacting with the Membership builders.
	Membership *MembershipClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// Provider is the client for interacting with the Provider builders.
	Provider *ProviderClient
	// Resource is the client for interacting with the Resource builders.
	Resource *ResourceClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Blueprint = NewBlueprintClient(c.config)
	c.Deployment = NewDeploymentClient(c.config)
	c.DeploymentNode = NewDeploymentNodeClient(c.config)
	c.GrantedPermission = NewGrantedPermissionClient(c.config)
	c.Group = NewGroupClient(c.config)
	c.GroupMembership = NewGroupMembershipClient(c.config)
	c.Membership = NewMembershipClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.Provider = NewProviderClient(c.config)
	c.Resource = NewResourceClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Blueprint:         NewBlueprintClient(cfg),
		Deployment:        NewDeploymentClient(cfg),
		DeploymentNode:    NewDeploymentNodeClient(cfg),
		GrantedPermission: NewGrantedPermissionClient(cfg),
		Group:             NewGroupClient(cfg),
		GroupMembership:   NewGroupMembershipClient(cfg),
		Membership:        NewMembershipClient(cfg),
		Project:           NewProjectClient(cfg),
		Provider:          NewProviderClient(cfg),
		Resource:          NewResourceClient(cfg),
		User:              NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Blueprint:         NewBlueprintClient(cfg),
		Deployment:        NewDeploymentClient(cfg),
		DeploymentNode:    NewDeploymentNodeClient(cfg),
		GrantedPermission: NewGrantedPermissionClient(cfg),
		Group:             NewGroupClient(cfg),
		GroupMembership:   NewGroupMembershipClient(cfg),
		Membership:        NewMembershipClient(cfg),
		Project:           NewProjectClient(cfg),
		Provider:          NewProviderClient(cfg),
		Resource:          NewResourceClient(cfg),
		User:              NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Blueprint.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Blueprint, c.Deployment, c.DeploymentNode, c.GrantedPermission, c.Group,
		c.GroupMembership, c.Membership, c.Project, c.Provider, c.Resource, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Blueprint, c.Deployment, c.DeploymentNode, c.GrantedPermission, c.Group,
		c.GroupMembership, c.Membership, c.Project, c.Provider, c.Resource, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BlueprintMutation:
		return c.Blueprint.mutate(ctx, m)
	case *DeploymentMutation:
		return c.Deployment.mutate(ctx, m)
	case *DeploymentNodeMutation:
		return c.DeploymentNode.mutate(ctx, m)
	case *GrantedPermissionMutation:
		return c.GrantedPermission.mutate(ctx, m)
	case *GroupMutation:
		return c.Group.mutate(ctx, m)
	case *GroupMembershipMutation:
		return c.GroupMembership.mutate(ctx, m)
	case *MembershipMutation:
		return c.Membership.mutate(ctx, m)
	case *ProjectMutation:
		return c.Project.mutate(ctx, m)
	case *ProviderMutation:
		return c.Provider.mutate(ctx, m)
	case *ResourceMutation:
		return c.Resource.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// BlueprintClient is a client for the Blueprint schema.
type BlueprintClient struct {
	config
}

// NewBlueprintClient returns a client for the Blueprint from the given config.
func NewBlueprintClient(c config) *BlueprintClient {
	return &BlueprintClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blueprint.Hooks(f(g(h())))`.
func (c *BlueprintClient) Use(hooks ...Hook) {
	c.hooks.Blueprint = append(c.hooks.Blueprint, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blueprint.Intercept(f(g(h())))`.
func (c *BlueprintClient) Intercept(interceptors ...Interceptor) {
	c.inters.Blueprint = append(c.inters.Blueprint, interceptors...)
}

// Create returns a builder for creating a Blueprint entity.
func (c *BlueprintClient) Create() *BlueprintCreate {
	mutation := newBlueprintMutation(c.config, OpCreate)
	return &BlueprintCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Blueprint entities.
func (c *BlueprintClient) CreateBulk(builders ...*BlueprintCreate) *BlueprintCreateBulk {
	return &BlueprintCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlueprintClient) MapCreateBulk(slice any, setFunc func(*BlueprintCreate, int)) *BlueprintCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlueprintCreateBulk{err: fmt.Errorf("calling to BlueprintClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlueprintCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlueprintCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Blueprint.
func (c *BlueprintClient) Update() *BlueprintUpdate {
	mutation := newBlueprintMutation(c.config, OpUpdate)
	return &BlueprintUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlueprintClient) UpdateOne(b *Blueprint) *BlueprintUpdateOne {
	mutation := newBlueprintMutation(c.config, OpUpdateOne, withBlueprint(b))
	return &BlueprintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlueprintClient) UpdateOneID(id uuid.UUID) *BlueprintUpdateOne {
	mutation := newBlueprintMutation(c.config, OpUpdateOne, withBlueprintID(id))
	return &BlueprintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Blueprint.
func (c *BlueprintClient) Delete() *BlueprintDelete {
	mutation := newBlueprintMutation(c.config, OpDelete)
	return &BlueprintDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlueprintClient) DeleteOne(b *Blueprint) *BlueprintDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlueprintClient) DeleteOneID(id uuid.UUID) *BlueprintDeleteOne {
	builder := c.Delete().Where(blueprint.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlueprintDeleteOne{builder}
}

// Query returns a query builder for Blueprint.
func (c *BlueprintClient) Query() *BlueprintQuery {
	return &BlueprintQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlueprint},
		inters: c.Interceptors(),
	}
}

// Get returns a Blueprint entity by its id.
func (c *BlueprintClient) Get(ctx context.Context, id uuid.UUID) (*Blueprint, error) {
	return c.Query().Where(blueprint.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlueprintClient) GetX(ctx context.Context, id uuid.UUID) *Blueprint {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvider queries the provider edge of a Blueprint.
func (c *BlueprintClient) QueryProvider(b *Blueprint) *ProviderQuery {
	query := (&ProviderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blueprint.Table, blueprint.FieldID, id),
			sqlgraph.To(entprovider.Table, entprovider.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, blueprint.ProviderTable, blueprint.ProviderColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a Blueprint.
func (c *BlueprintClient) QueryProject(b *Blueprint) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blueprint.Table, blueprint.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, blueprint.ProjectTable, blueprint.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResources queries the resources edge of a Blueprint.
func (c *BlueprintClient) QueryResources(b *Blueprint) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blueprint.Table, blueprint.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, blueprint.ResourcesTable, blueprint.ResourcesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeployments queries the deployments edge of a Blueprint.
func (c *BlueprintClient) QueryDeployments(b *Blueprint) *DeploymentQuery {
	query := (&DeploymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blueprint.Table, blueprint.FieldID, id),
			sqlgraph.To(deployment.Table, deployment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, blueprint.DeploymentsTable, blueprint.DeploymentsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlueprintClient) Hooks() []Hook {
	return c.hooks.Blueprint
}

// Interceptors returns the client interceptors.
func (c *BlueprintClient) Interceptors() []Interceptor {
	return c.inters.Blueprint
}

func (c *BlueprintClient) mutate(ctx context.Context, m *BlueprintMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlueprintCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlueprintUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlueprintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlueprintDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Blueprint mutation op: %q", m.Op())
	}
}

// DeploymentClient is a client for the Deployment schema.
type DeploymentClient struct {
	config
}

// NewDeploymentClient returns a client for the Deployment from the given config.
func NewDeploymentClient(c config) *DeploymentClient {
	return &DeploymentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deployment.Hooks(f(g(h())))`.
func (c *DeploymentClient) Use(hooks ...Hook) {
	c.hooks.Deployment = append(c.hooks.Deployment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deployment.Intercept(f(g(h())))`.
func (c *DeploymentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Deployment = append(c.inters.Deployment, interceptors...)
}

// Create returns a builder for creating a Deployment entity.
func (c *DeploymentClient) Create() *DeploymentCreate {
	mutation := newDeploymentMutation(c.config, OpCreate)
	return &DeploymentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Deployment entities.
func (c *DeploymentClient) CreateBulk(builders ...*DeploymentCreate) *DeploymentCreateBulk {
	return &DeploymentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeploymentClient) MapCreateBulk(slice any, setFunc func(*DeploymentCreate, int)) *DeploymentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeploymentCreateBulk{err: fmt.Errorf("calling to DeploymentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeploymentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeploymentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Deployment.
func (c *DeploymentClient) Update() *DeploymentUpdate {
	mutation := newDeploymentMutation(c.config, OpUpdate)
	return &DeploymentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeploymentClient) UpdateOne(d *Deployment) *DeploymentUpdateOne {
	mutation := newDeploymentMutation(c.config, OpUpdateOne, withDeployment(d))
	return &DeploymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeploymentClient) UpdateOneID(id uuid.UUID) *DeploymentUpdateOne {
	mutation := newDeploymentMutation(c.config, OpUpdateOne, withDeploymentID(id))
	return &DeploymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Deployment.
func (c *DeploymentClient) Delete() *DeploymentDelete {
	mutation := newDeploymentMutation(c.config, OpDelete)
	return &DeploymentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeploymentClient) DeleteOne(d *Deployment) *DeploymentDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeploymentClient) DeleteOneID(id uuid.UUID) *DeploymentDeleteOne {
	builder := c.Delete().Where(deployment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeploymentDeleteOne{builder}
}

// Query returns a query builder for Deployment.
func (c *DeploymentClient) Query() *DeploymentQuery {
	return &DeploymentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeployment},
		inters: c.Interceptors(),
	}
}

// Get returns a Deployment entity by its id.
func (c *DeploymentClient) Get(ctx context.Context, id uuid.UUID) (*Deployment, error) {
	return c.Query().Where(deployment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeploymentClient) GetX(ctx context.Context, id uuid.UUID) *Deployment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlueprint queries the blueprint edge of a Deployment.
func (c *DeploymentClient) QueryBlueprint(d *Deployment) *BlueprintQuery {
	query := (&BlueprintClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deployment.Table, deployment.FieldID, id),
			sqlgraph.To(blueprint.Table, blueprint.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, deployment.BlueprintTable, deployment.BlueprintColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeploymentNodes queries the deployment_nodes edge of a Deployment.
func (c *DeploymentClient) QueryDeploymentNodes(d *Deployment) *DeploymentNodeQuery {
	query := (&DeploymentNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deployment.Table, deployment.FieldID, id),
			sqlgraph.To(deploymentnode.Table, deploymentnode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, deployment.DeploymentNodesTable, deployment.DeploymentNodesColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRequester queries the requester edge of a Deployment.
func (c *DeploymentClient) QueryRequester(d *Deployment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deployment.Table, deployment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, deployment.RequesterTable, deployment.RequesterColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a Deployment.
func (c *DeploymentClient) QueryProject(d *Deployment) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deployment.Table, deployment.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, deployment.ProjectTable, deployment.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeploymentClient) Hooks() []Hook {
	return c.hooks.Deployment
}

// Interceptors returns the client interceptors.
func (c *DeploymentClient) Interceptors() []Interceptor {
	return c.inters.Deployment
}

func (c *DeploymentClient) mutate(ctx context.Context, m *DeploymentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeploymentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeploymentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeploymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeploymentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Deployment mutation op: %q", m.Op())
	}
}

// DeploymentNodeClient is a client for the DeploymentNode schema.
type DeploymentNodeClient struct {
	config
}

// NewDeploymentNodeClient returns a client for the DeploymentNode from the given config.
func NewDeploymentNodeClient(c config) *DeploymentNodeClient {
	return &DeploymentNodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deploymentnode.Hooks(f(g(h())))`.
func (c *DeploymentNodeClient) Use(hooks ...Hook) {
	c.hooks.DeploymentNode = append(c.hooks.DeploymentNode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deploymentnode.Intercept(f(g(h())))`.
func (c *DeploymentNodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeploymentNode = append(c.inters.DeploymentNode, interceptors...)
}

// Create returns a builder for creating a DeploymentNode entity.
func (c *DeploymentNodeClient) Create() *DeploymentNodeCreate {
	mutation := newDeploymentNodeMutation(c.config, OpCreate)
	return &DeploymentNodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeploymentNode entities.
func (c *DeploymentNodeClient) CreateBulk(builders ...*DeploymentNodeCreate) *DeploymentNodeCreateBulk {
	return &DeploymentNodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeploymentNodeClient) MapCreateBulk(slice any, setFunc func(*DeploymentNodeCreate, int)) *DeploymentNodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeploymentNodeCreateBulk{err: fmt.Errorf("calling to DeploymentNodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeploymentNodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeploymentNodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeploymentNode.
func (c *DeploymentNodeClient) Update() *DeploymentNodeUpdate {
	mutation := newDeploymentNodeMutation(c.config, OpUpdate)
	return &DeploymentNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeploymentNodeClient) UpdateOne(dn *DeploymentNode) *DeploymentNodeUpdateOne {
	mutation := newDeploymentNodeMutation(c.config, OpUpdateOne, withDeploymentNode(dn))
	return &DeploymentNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeploymentNodeClient) UpdateOneID(id uuid.UUID) *DeploymentNodeUpdateOne {
	mutation := newDeploymentNodeMutation(c.config, OpUpdateOne, withDeploymentNodeID(id))
	return &DeploymentNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeploymentNode.
func (c *DeploymentNodeClient) Delete() *DeploymentNodeDelete {
	mutation := newDeploymentNodeMutation(c.config, OpDelete)
	return &DeploymentNodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeploymentNodeClient) DeleteOne(dn *DeploymentNode) *DeploymentNodeDeleteOne {
	return c.DeleteOneID(dn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeploymentNodeClient) DeleteOneID(id uuid.UUID) *DeploymentNodeDeleteOne {
	builder := c.Delete().Where(deploymentnode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeploymentNodeDeleteOne{builder}
}

// Query returns a query builder for DeploymentNode.
func (c *DeploymentNodeClient) Query() *DeploymentNodeQuery {
	return &DeploymentNodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeploymentNode},
		inters: c.Interceptors(),
	}
}

// Get returns a DeploymentNode entity by its id.
func (c *DeploymentNodeClient) Get(ctx context.Context, id uuid.UUID) (*DeploymentNode, error) {
	return c.Query().Where(deploymentnode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeploymentNodeClient) GetX(ctx context.Context, id uuid.UUID) *DeploymentNode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeployment queries the deployment edge of a DeploymentNode.
func (c *DeploymentNodeClient) QueryDeployment(dn *DeploymentNode) *DeploymentQuery {
	query := (&DeploymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymentnode.Table, deploymentnode.FieldID, id),
			sqlgraph.To(deployment.Table, deployment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, deploymentnode.DeploymentTable, deploymentnode.DeploymentColumn),
		)
		fromV = sqlgraph.Neighbors(dn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResource queries the resource edge of a DeploymentNode.
func (c *DeploymentNodeClient) QueryResource(dn *DeploymentNode) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymentnode.Table, deploymentnode.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, deploymentnode.ResourceTable, deploymentnode.ResourceColumn),
		)
		fromV = sqlgraph.Neighbors(dn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrevNodes queries the prev_nodes edge of a DeploymentNode.
func (c *DeploymentNodeClient) QueryPrevNodes(dn *DeploymentNode) *DeploymentNodeQuery {
	query := (&DeploymentNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymentnode.Table, deploymentnode.FieldID, id),
			sqlgraph.To(deploymentnode.Table, deploymentnode.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, deploymentnode.PrevNodesTable, deploymentnode.PrevNodesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(dn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNextNodes queries the next_nodes edge of a DeploymentNode.
func (c *DeploymentNodeClient) QueryNextNodes(dn *DeploymentNode) *DeploymentNodeQuery {
	query := (&DeploymentNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymentnode.Table, deploymentnode.FieldID, id),
			sqlgraph.To(deploymentnode.Table, deploymentnode.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, deploymentnode.NextNodesTable, deploymentnode.NextNodesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(dn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeploymentNodeClient) Hooks() []Hook {
	return c.hooks.DeploymentNode
}

// Interceptors returns the client interceptors.
func (c *DeploymentNodeClient) Interceptors() []Interceptor {
	return c.inters.DeploymentNode
}

func (c *DeploymentNodeClient) mutate(ctx context.Context, m *DeploymentNodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeploymentNodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeploymentNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeploymentNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeploymentNodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DeploymentNode mutation op: %q", m.Op())
	}
}

// GrantedPermissionClient is a client for the GrantedPermission schema.
type GrantedPermissionClient struct {
	config
}

// NewGrantedPermissionClient returns a client for the GrantedPermission from the given config.
func NewGrantedPermissionClient(c config) *GrantedPermissionClient {
	return &GrantedPermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `grantedpermission.Hooks(f(g(h())))`.
func (c *GrantedPermissionClient) Use(hooks ...Hook) {
	c.hooks.GrantedPermission = append(c.hooks.GrantedPermission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `grantedpermission.Intercept(f(g(h())))`.
func (c *GrantedPermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.GrantedPermission = append(c.inters.GrantedPermission, interceptors...)
}

// Create returns a builder for creating a GrantedPermission entity.
func (c *GrantedPermissionClient) Create() *GrantedPermissionCreate {
	mutation := newGrantedPermissionMutation(c.config, OpCreate)
	return &GrantedPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GrantedPermission entities.
func (c *GrantedPermissionClient) CreateBulk(builders ...*GrantedPermissionCreate) *GrantedPermissionCreateBulk {
	return &GrantedPermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GrantedPermissionClient) MapCreateBulk(slice any, setFunc func(*GrantedPermissionCreate, int)) *GrantedPermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GrantedPermissionCreateBulk{err: fmt.Errorf("calling to GrantedPermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GrantedPermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GrantedPermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GrantedPermission.
func (c *GrantedPermissionClient) Update() *GrantedPermissionUpdate {
	mutation := newGrantedPermissionMutation(c.config, OpUpdate)
	return &GrantedPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GrantedPermissionClient) UpdateOne(gp *GrantedPermission) *GrantedPermissionUpdateOne {
	mutation := newGrantedPermissionMutation(c.config, OpUpdateOne, withGrantedPermission(gp))
	return &GrantedPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GrantedPermissionClient) UpdateOneID(id uuid.UUID) *GrantedPermissionUpdateOne {
	mutation := newGrantedPermissionMutation(c.config, OpUpdateOne, withGrantedPermissionID(id))
	return &GrantedPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GrantedPermission.
func (c *GrantedPermissionClient) Delete() *GrantedPermissionDelete {
	mutation := newGrantedPermissionMutation(c.config, OpDelete)
	return &GrantedPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GrantedPermissionClient) DeleteOne(gp *GrantedPermission) *GrantedPermissionDeleteOne {
	return c.DeleteOneID(gp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GrantedPermissionClient) DeleteOneID(id uuid.UUID) *GrantedPermissionDeleteOne {
	builder := c.Delete().Where(grantedpermission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GrantedPermissionDeleteOne{builder}
}

// Query returns a query builder for GrantedPermission.
func (c *GrantedPermissionClient) Query() *GrantedPermissionQuery {
	return &GrantedPermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGrantedPermission},
		inters: c.Interceptors(),
	}
}

// Get returns a GrantedPermission entity by its id.
func (c *GrantedPermissionClient) Get(ctx context.Context, id uuid.UUID) (*GrantedPermission, error) {
	return c.Query().Where(grantedpermission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GrantedPermissionClient) GetX(ctx context.Context, id uuid.UUID) *GrantedPermission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a GrantedPermission.
func (c *GrantedPermissionClient) QueryUser(gp *GrantedPermission) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grantedpermission.Table, grantedpermission.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, grantedpermission.UserTable, grantedpermission.UserColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroup queries the group edge of a GrantedPermission.
func (c *GrantedPermissionClient) QueryGroup(gp *GrantedPermission) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grantedpermission.Table, grantedpermission.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, grantedpermission.GroupTable, grantedpermission.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GrantedPermissionClient) Hooks() []Hook {
	return c.hooks.GrantedPermission
}

// Interceptors returns the client interceptors.
func (c *GrantedPermissionClient) Interceptors() []Interceptor {
	return c.inters.GrantedPermission
}

func (c *GrantedPermissionClient) mutate(ctx context.Context, m *GrantedPermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GrantedPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GrantedPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GrantedPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GrantedPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GrantedPermission mutation op: %q", m.Op())
	}
}

// GroupClient is a client for the Group schema.
type GroupClient struct {
	config
}

// NewGroupClient returns a client for the Group from the given config.
func NewGroupClient(c config) *GroupClient {
	return &GroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `group.Hooks(f(g(h())))`.
func (c *GroupClient) Use(hooks ...Hook) {
	c.hooks.Group = append(c.hooks.Group, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `group.Intercept(f(g(h())))`.
func (c *GroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.Group = append(c.inters.Group, interceptors...)
}

// Create returns a builder for creating a Group entity.
func (c *GroupClient) Create() *GroupCreate {
	mutation := newGroupMutation(c.config, OpCreate)
	return &GroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Group entities.
func (c *GroupClient) CreateBulk(builders ...*GroupCreate) *GroupCreateBulk {
	return &GroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupClient) MapCreateBulk(slice any, setFunc func(*GroupCreate, int)) *GroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupCreateBulk{err: fmt.Errorf("calling to GroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Group.
func (c *GroupClient) Update() *GroupUpdate {
	mutation := newGroupMutation(c.config, OpUpdate)
	return &GroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupClient) UpdateOne(gr *Group) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroup(gr))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupClient) UpdateOneID(id uuid.UUID) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroupID(id))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Group.
func (c *GroupClient) Delete() *GroupDelete {
	mutation := newGroupMutation(c.config, OpDelete)
	return &GroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupClient) DeleteOne(gr *Group) *GroupDeleteOne {
	return c.DeleteOneID(gr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupClient) DeleteOneID(id uuid.UUID) *GroupDeleteOne {
	builder := c.Delete().Where(group.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupDeleteOne{builder}
}

// Query returns a query builder for Group.
func (c *GroupClient) Query() *GroupQuery {
	return &GroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a Group entity by its id.
func (c *GroupClient) Get(ctx context.Context, id uuid.UUID) (*Group, error) {
	return c.Query().Where(group.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupClient) GetX(ctx context.Context, id uuid.UUID) *Group {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Group.
func (c *GroupClient) QueryUsers(gr *Group) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.UsersTable, group.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProjects queries the projects edge of a Group.
func (c *GroupClient) QueryProjects(gr *Group) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ProjectsTable, group.ProjectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupClient) Hooks() []Hook {
	return c.hooks.Group
}

// Interceptors returns the client interceptors.
func (c *GroupClient) Interceptors() []Interceptor {
	return c.inters.Group
}

func (c *GroupClient) mutate(ctx context.Context, m *GroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Group mutation op: %q", m.Op())
	}
}

// GroupMembershipClient is a client for the GroupMembership schema.
type GroupMembershipClient struct {
	config
}

// NewGroupMembershipClient returns a client for the GroupMembership from the given config.
func NewGroupMembershipClient(c config) *GroupMembershipClient {
	return &GroupMembershipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupmembership.Hooks(f(g(h())))`.
func (c *GroupMembershipClient) Use(hooks ...Hook) {
	c.hooks.GroupMembership = append(c.hooks.GroupMembership, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `groupmembership.Intercept(f(g(h())))`.
func (c *GroupMembershipClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupMembership = append(c.inters.GroupMembership, interceptors...)
}

// Create returns a builder for creating a GroupMembership entity.
func (c *GroupMembershipClient) Create() *GroupMembershipCreate {
	mutation := newGroupMembershipMutation(c.config, OpCreate)
	return &GroupMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupMembership entities.
func (c *GroupMembershipClient) CreateBulk(builders ...*GroupMembershipCreate) *GroupMembershipCreateBulk {
	return &GroupMembershipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupMembershipClient) MapCreateBulk(slice any, setFunc func(*GroupMembershipCreate, int)) *GroupMembershipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupMembershipCreateBulk{err: fmt.Errorf("calling to GroupMembershipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupMembershipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupMembershipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupMembership.
func (c *GroupMembershipClient) Update() *GroupMembershipUpdate {
	mutation := newGroupMembershipMutation(c.config, OpUpdate)
	return &GroupMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupMembershipClient) UpdateOne(gm *GroupMembership) *GroupMembershipUpdateOne {
	mutation := newGroupMembershipMutation(c.config, OpUpdateOne, withGroupMembership(gm))
	return &GroupMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupMembershipClient) UpdateOneID(id uuid.UUID) *GroupMembershipUpdateOne {
	mutation := newGroupMembershipMutation(c.config, OpUpdateOne, withGroupMembershipID(id))
	return &GroupMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupMembership.
func (c *GroupMembershipClient) Delete() *GroupMembershipDelete {
	mutation := newGroupMembershipMutation(c.config, OpDelete)
	return &GroupMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupMembershipClient) DeleteOne(gm *GroupMembership) *GroupMembershipDeleteOne {
	return c.DeleteOneID(gm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupMembershipClient) DeleteOneID(id uuid.UUID) *GroupMembershipDeleteOne {
	builder := c.Delete().Where(groupmembership.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupMembershipDeleteOne{builder}
}

// Query returns a query builder for GroupMembership.
func (c *GroupMembershipClient) Query() *GroupMembershipQuery {
	return &GroupMembershipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupMembership},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupMembership entity by its id.
func (c *GroupMembershipClient) Get(ctx context.Context, id uuid.UUID) (*GroupMembership, error) {
	return c.Query().Where(groupmembership.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupMembershipClient) GetX(ctx context.Context, id uuid.UUID) *GroupMembership {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a GroupMembership.
func (c *GroupMembershipClient) QueryProject(gm *GroupMembership) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupmembership.Table, groupmembership.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, groupmembership.ProjectTable, groupmembership.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(gm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroup queries the group edge of a GroupMembership.
func (c *GroupMembershipClient) QueryGroup(gm *GroupMembership) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupmembership.Table, groupmembership.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, groupmembership.GroupTable, groupmembership.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(gm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupMembershipClient) Hooks() []Hook {
	return c.hooks.GroupMembership
}

// Interceptors returns the client interceptors.
func (c *GroupMembershipClient) Interceptors() []Interceptor {
	return c.inters.GroupMembership
}

func (c *GroupMembershipClient) mutate(ctx context.Context, m *GroupMembershipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GroupMembership mutation op: %q", m.Op())
	}
}

// MembershipClient is a client for the Membership schema.
type MembershipClient struct {
	config
}

// NewMembershipClient returns a client for the Membership from the given config.
func NewMembershipClient(c config) *MembershipClient {
	return &MembershipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `membership.Hooks(f(g(h())))`.
func (c *MembershipClient) Use(hooks ...Hook) {
	c.hooks.Membership = append(c.hooks.Membership, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `membership.Intercept(f(g(h())))`.
func (c *MembershipClient) Intercept(interceptors ...Interceptor) {
	c.inters.Membership = append(c.inters.Membership, interceptors...)
}

// Create returns a builder for creating a Membership entity.
func (c *MembershipClient) Create() *MembershipCreate {
	mutation := newMembershipMutation(c.config, OpCreate)
	return &MembershipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Membership entities.
func (c *MembershipClient) CreateBulk(builders ...*MembershipCreate) *MembershipCreateBulk {
	return &MembershipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MembershipClient) MapCreateBulk(slice any, setFunc func(*MembershipCreate, int)) *MembershipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MembershipCreateBulk{err: fmt.Errorf("calling to MembershipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MembershipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MembershipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Membership.
func (c *MembershipClient) Update() *MembershipUpdate {
	mutation := newMembershipMutation(c.config, OpUpdate)
	return &MembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MembershipClient) UpdateOne(m *Membership) *MembershipUpdateOne {
	mutation := newMembershipMutation(c.config, OpUpdateOne, withMembership(m))
	return &MembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MembershipClient) UpdateOneID(id uuid.UUID) *MembershipUpdateOne {
	mutation := newMembershipMutation(c.config, OpUpdateOne, withMembershipID(id))
	return &MembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Membership.
func (c *MembershipClient) Delete() *MembershipDelete {
	mutation := newMembershipMutation(c.config, OpDelete)
	return &MembershipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MembershipClient) DeleteOne(m *Membership) *MembershipDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MembershipClient) DeleteOneID(id uuid.UUID) *MembershipDeleteOne {
	builder := c.Delete().Where(membership.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MembershipDeleteOne{builder}
}

// Query returns a query builder for Membership.
func (c *MembershipClient) Query() *MembershipQuery {
	return &MembershipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMembership},
		inters: c.Interceptors(),
	}
}

// Get returns a Membership entity by its id.
func (c *MembershipClient) Get(ctx context.Context, id uuid.UUID) (*Membership, error) {
	return c.Query().Where(membership.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MembershipClient) GetX(ctx context.Context, id uuid.UUID) *Membership {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Membership.
func (c *MembershipClient) QueryProject(m *Membership) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membership.Table, membership.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, membership.ProjectTable, membership.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Membership.
func (c *MembershipClient) QueryUser(m *Membership) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membership.Table, membership.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, membership.UserTable, membership.UserColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MembershipClient) Hooks() []Hook {
	return c.hooks.Membership
}

// Interceptors returns the client interceptors.
func (c *MembershipClient) Interceptors() []Interceptor {
	return c.inters.Membership
}

func (c *MembershipClient) mutate(ctx context.Context, m *MembershipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MembershipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MembershipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Membership mutation op: %q", m.Op())
	}
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Project = append(c.inters.Project, interceptors...)
}

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectClient) MapCreateBulk(slice any, setFunc func(*ProjectCreate, int)) *ProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectCreateBulk{err: fmt.Errorf("calling to ProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(pr *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(pr))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id uuid.UUID) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(pr *Project) *ProjectDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id uuid.UUID) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id uuid.UUID) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id uuid.UUID) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMembers queries the members edge of a Project.
func (c *ProjectClient) QueryMembers(pr *Project) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, project.MembersTable, project.MembersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroupMembers queries the group_members edge of a Project.
func (c *ProjectClient) QueryGroupMembers(pr *Project) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, project.GroupMembersTable, project.GroupMembersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlueprints queries the blueprints edge of a Project.
func (c *ProjectClient) QueryBlueprints(pr *Project) *BlueprintQuery {
	query := (&BlueprintClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(blueprint.Table, blueprint.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, project.BlueprintsTable, project.BlueprintsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeployments queries the deployments edge of a Project.
func (c *ProjectClient) QueryDeployments(pr *Project) *DeploymentQuery {
	query := (&DeploymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(deployment.Table, deployment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, project.DeploymentsTable, project.DeploymentsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberships queries the memberships edge of a Project.
func (c *ProjectClient) QueryMemberships(pr *Project) *MembershipQuery {
	query := (&MembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(membership.Table, membership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, project.MembershipsTable, project.MembershipsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroupMemberships queries the group_memberships edge of a Project.
func (c *ProjectClient) QueryGroupMemberships(pr *Project) *GroupMembershipQuery {
	query := (&GroupMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(groupmembership.Table, groupmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, project.GroupMembershipsTable, project.GroupMembershipsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	return c.hooks.Project
}

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor {
	return c.inters.Project
}

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Project mutation op: %q", m.Op())
	}
}

// ProviderClient is a client for the Provider schema.
type ProviderClient struct {
	config
}

// NewProviderClient returns a client for the Provider from the given config.
func NewProviderClient(c config) *ProviderClient {
	return &ProviderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entprovider.Hooks(f(g(h())))`.
func (c *ProviderClient) Use(hooks ...Hook) {
	c.hooks.Provider = append(c.hooks.Provider, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entprovider.Intercept(f(g(h())))`.
func (c *ProviderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Provider = append(c.inters.Provider, interceptors...)
}

// Create returns a builder for creating a Provider entity.
func (c *ProviderClient) Create() *ProviderCreate {
	mutation := newProviderMutation(c.config, OpCreate)
	return &ProviderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Provider entities.
func (c *ProviderClient) CreateBulk(builders ...*ProviderCreate) *ProviderCreateBulk {
	return &ProviderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProviderClient) MapCreateBulk(slice any, setFunc func(*ProviderCreate, int)) *ProviderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProviderCreateBulk{err: fmt.Errorf("calling to ProviderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProviderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProviderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Provider.
func (c *ProviderClient) Update() *ProviderUpdate {
	mutation := newProviderMutation(c.config, OpUpdate)
	return &ProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProviderClient) UpdateOne(pr *Provider) *ProviderUpdateOne {
	mutation := newProviderMutation(c.config, OpUpdateOne, withProvider(pr))
	return &ProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProviderClient) UpdateOneID(id uuid.UUID) *ProviderUpdateOne {
	mutation := newProviderMutation(c.config, OpUpdateOne, withProviderID(id))
	return &ProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Provider.
func (c *ProviderClient) Delete() *ProviderDelete {
	mutation := newProviderMutation(c.config, OpDelete)
	return &ProviderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProviderClient) DeleteOne(pr *Provider) *ProviderDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProviderClient) DeleteOneID(id uuid.UUID) *ProviderDeleteOne {
	builder := c.Delete().Where(entprovider.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProviderDeleteOne{builder}
}

// Query returns a query builder for Provider.
func (c *ProviderClient) Query() *ProviderQuery {
	return &ProviderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvider},
		inters: c.Interceptors(),
	}
}

// Get returns a Provider entity by its id.
func (c *ProviderClient) Get(ctx context.Context, id uuid.UUID) (*Provider, error) {
	return c.Query().Where(entprovider.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProviderClient) GetX(ctx context.Context, id uuid.UUID) *Provider {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlueprints queries the blueprints edge of a Provider.
func (c *ProviderClient) QueryBlueprints(pr *Provider) *BlueprintQuery {
	query := (&BlueprintClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entprovider.Table, entprovider.FieldID, id),
			sqlgraph.To(blueprint.Table, blueprint.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, entprovider.BlueprintsTable, entprovider.BlueprintsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProviderClient) Hooks() []Hook {
	return c.hooks.Provider
}

// Interceptors returns the client interceptors.
func (c *ProviderClient) Interceptors() []Interceptor {
	return c.inters.Provider
}

func (c *ProviderClient) mutate(ctx context.Context, m *ProviderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProviderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProviderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Provider mutation op: %q", m.Op())
	}
}

// ResourceClient is a client for the Resource schema.
type ResourceClient struct {
	config
}

// NewResourceClient returns a client for the Resource from the given config.
func NewResourceClient(c config) *ResourceClient {
	return &ResourceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resource.Hooks(f(g(h())))`.
func (c *ResourceClient) Use(hooks ...Hook) {
	c.hooks.Resource = append(c.hooks.Resource, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resource.Intercept(f(g(h())))`.
func (c *ResourceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Resource = append(c.inters.Resource, interceptors...)
}

// Create returns a builder for creating a Resource entity.
func (c *ResourceClient) Create() *ResourceCreate {
	mutation := newResourceMutation(c.config, OpCreate)
	return &ResourceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Resource entities.
func (c *ResourceClient) CreateBulk(builders ...*ResourceCreate) *ResourceCreateBulk {
	return &ResourceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceClient) MapCreateBulk(slice any, setFunc func(*ResourceCreate, int)) *ResourceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceCreateBulk{err: fmt.Errorf("calling to ResourceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Resource.
func (c *ResourceClient) Update() *ResourceUpdate {
	mutation := newResourceMutation(c.config, OpUpdate)
	return &ResourceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceClient) UpdateOne(r *Resource) *ResourceUpdateOne {
	mutation := newResourceMutation(c.config, OpUpdateOne, withResource(r))
	return &ResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceClient) UpdateOneID(id uuid.UUID) *ResourceUpdateOne {
	mutation := newResourceMutation(c.config, OpUpdateOne, withResourceID(id))
	return &ResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Resource.
func (c *ResourceClient) Delete() *ResourceDelete {
	mutation := newResourceMutation(c.config, OpDelete)
	return &ResourceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceClient) DeleteOne(r *Resource) *ResourceDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceClient) DeleteOneID(id uuid.UUID) *ResourceDeleteOne {
	builder := c.Delete().Where(resource.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceDeleteOne{builder}
}

// Query returns a query builder for Resource.
func (c *ResourceClient) Query() *ResourceQuery {
	return &ResourceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResource},
		inters: c.Interceptors(),
	}
}

// Get returns a Resource entity by its id.
func (c *ResourceClient) Get(ctx context.Context, id uuid.UUID) (*Resource, error) {
	return c.Query().Where(resource.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceClient) GetX(ctx context.Context, id uuid.UUID) *Resource {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlueprint queries the blueprint edge of a Resource.
func (c *ResourceClient) QueryBlueprint(r *Resource) *BlueprintQuery {
	query := (&BlueprintClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(blueprint.Table, blueprint.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, resource.BlueprintTable, resource.BlueprintColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependsOn queries the depends_on edge of a Resource.
func (c *ResourceClient) QueryDependsOn(r *Resource) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, resource.DependsOnTable, resource.DependsOnPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRequiredBy queries the required_by edge of a Resource.
func (c *ResourceClient) QueryRequiredBy(r *Resource) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, resource.RequiredByTable, resource.RequiredByPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceClient) Hooks() []Hook {
	return c.hooks.Resource
}

// Interceptors returns the client interceptors.
func (c *ResourceClient) Interceptors() []Interceptor {
	return c.inters.Resource
}

func (c *ResourceClient) mutate(ctx context.Context, m *ResourceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Resource mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroups queries the groups edge of a User.
func (c *UserClient) QueryGroups(u *User) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.GroupsTable, user.GroupsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeployments queries the deployments edge of a User.
func (c *UserClient) QueryDeployments(u *User) *DeploymentQuery {
	query := (&DeploymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(deployment.Table, deployment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.DeploymentsTable, user.DeploymentsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProjects queries the projects edge of a User.
func (c *UserClient) QueryProjects(u *User) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.ProjectsTable, user.ProjectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Blueprint, Deployment, DeploymentNode, GrantedPermission, Group,
		GroupMembership, Membership, Project, Provider, Resource, User []ent.Hook
	}
	inters struct {
		Blueprint, Deployment, DeploymentNode, GrantedPermission, Group,
		GroupMembership, Membership, Project, Provider, Resource,
		User []ent.Interceptor
	}
)
